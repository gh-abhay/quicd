
[package]
name = "quicd"
version = "0.1.0"
edition = "2021"

[dependencies]
bytes = { workspace = true }
clap = { workspace = true, features = ["derive"] }
serde = { workspace = true, features = ["derive"] }
serde_json = { workspace = true }
config = { workspace = true }
toml = { workspace = true }
anyhow = { workspace = true }
sys-info = { workspace = true }
tokio = { workspace = true, features = ["rt-multi-thread", "macros", "signal", "sync"] }
tokio-stream = { workspace = true, features = ["sync"] }
num_cpus = { workspace = true }
datagram-socket = { workspace = true }
io-uring = { workspace = true }
socket2 = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true, features = ["fmt", "env-filter", "json"] }
libc = { workspace = true }
nix = { workspace = true, features = ["user"] }
smallvec = { workspace = true }
ahash = { workspace = true }
once_cell = { workspace = true }
crossbeam-channel = { workspace = true }
core_affinity = { workspace = true }
rcgen = { workspace = true }
slab = { workspace = true }
parking_lot = { workspace = true }

# OpenTelemetry for metrics and tracing
opentelemetry = { workspace = true, features = ["metrics", "trace"] }
opentelemetry-otlp = { workspace = true, features = ["metrics", "trace", "grpc-tonic"] }
opentelemetry_sdk = { workspace = true, features = ["rt-tokio", "metrics", "trace"] }
opentelemetry-semantic-conventions = { workspace = true }
tracing-opentelemetry = { workspace = true }
libloading = { workspace = true }

# Internal crates
quicd-quic = { path = "../quicd-quic", features = ["boring-crypto"] }
quicd-x = { path = "../quicd-x" }
quicd-h3 = { path = "../quicd-h3" }
quicd-hq-interop = { path = "../quicd-hq-interop" }

# eBPF routing dependencies
aya = { workspace = true }
siphasher = "1.0"
getrandom = "0.2"
log = "0.4"
ebpf = { path = "../ebpf" }
rand = "0.9.2"
lru = "0.12"

[dev-dependencies]
criterion = { workspace = true }

[[bench]]
name = "netio_buffer"
harness = false

[[bench]]
name = "routing_benchmark"
harness = false

[build-dependencies]
anyhow = { workspace = true }
aya-build = { workspace = true }
cargo_metadata = { workspace = true }
# TODO(https://github.com/rust-lang/cargo/issues/12375): this should be an artifact dependency, but
# it's not possible to tell cargo to use `-Z build-std` to build it. We cargo-in-cargo in the build
# script to build this, but we want to teach cargo about the dependecy so that cache invalidation
# works properly.
#
# Note also that https://github.com/rust-lang/cargo/issues/10593 occurs when `target = ...` is added
# to an artifact dependency; it seems possible to work around that by setting `resolver = "1"` in
# Cargo.toml in the workspace root.
#
# Finally note that *any* usage of `artifact = ...` in *any* Cargo.toml in the workspace breaks
# workflows with stable cargo; stable cargo outright refuses to load manifests that use unstable
# features.
ebpf = { path = "../ebpf" }
